{
  "version": 3,
  "sources": ["/Users/jcorbin/borkshop-js/packages/jspit/src/tiles.ts"],
  "sourcesContent": ["export interface Point {\n  x: number,\n  y: number,\n}\n\nexport interface TileSpec {\n  text?: string\n  pos?: Point\n  tag?: string|string[]\n  fg?: string\n  bg?: string\n  data?: TileData\n}\n\ntype TileDatum =\n  | string\n  | number\n  | TileDatum[]\n  | TileData\n\ninterface TileData {\n  [name: string]: TileDatum\n}\n\n// mortonSpread inserts a 0 bit after each of 26 the low bits of x, masking\n// away any higher bits; this is the best we can do in JavaScript since integer\n// precision maxes out at 53 bits.\nfunction mortonSpread1(x:number):number {\n  x =  x             & 0x00000002ffffff; // x = ---- ----  ---- ----  ---- ----  ---- --98  7654 3210  fedc ba98  7654 3210\n  x = (x ^ (x << 8)) & 0x0200ff00ff00ff; // x = ---- --98  ---- ----  7654 3210  ---- ----  fedc ba98  ---- ----  7654 3210\n  x = (x ^ (x << 4)) & 0x020f0f0f0f0f0f; // x = ---- ----  ---- 7654  ---- 3210  ---- fedc  ---- ba98  ---- 7654  ---- 3210\n  x = (x ^ (x << 2)) & 0x02333333333333; // x = ---- --98  --76 --54  --32 --10  --fe --dc  --ba --98  --76 --54  --32 --10\n  x = (x ^ (x << 1)) & 0x05555555555555; // x = ---- -9-8  -6-6 -5-4  -3-2 -1-0  -f-e -d-c  -b-a -9-8  -7-6 -5-4  -3-2 -1-0\n  return x;\n}\n\n// mortonKey returns the Z-order curve index for a Point, aka its \"Morton code\"\n// https://en.wikipedia.org/wiki/Z-order_curve\nfunction mortonKey({x, y}:Point):number {\n  return mortonSpread1(Math.floor(x)) | mortonSpread1(Math.floor(y))<<1;\n}\n\ninterface TileSpatialIndex {\n  update(ids:string[], pos:Point[]):void\n  tilesAt(at:Point):Set<string>|undefined\n  // TODO range query\n}\n\nclass TileMortonIndex {\n  #fore = new Map<number, Set<string>>();\n  #back = new Map<string, number>();\n\n  update(ids:string[], pos:Point[]) {\n    for (const [i, id] of ids.entries()) {\n      const pt = pos[i];\n      const key = mortonKey(pt);\n      const prior = this.#back.get(id);\n      if (prior !== undefined) this.#fore.get(prior)?.delete(id);\n      const at = this.#fore.get(key);\n      if (at) at.add(id);\n      else this.#fore.set(key, new Set([id]));\n      this.#back.set(id, key);\n    }\n  }\n\n  tilesAt(at:Point) {\n    return this.#fore.get(mortonKey(at));\n  }\n}\n\nexport class TileGrid {\n  el : HTMLElement\n\n  constructor(el:HTMLElement) {\n    this.el = el;\n    // TODO handle resize events\n  }\n\n  get tileSize(): Point {\n    // TODO use an invisible ghost tile? cache?\n    for (const tile of this.el.querySelectorAll('.tile')) {\n      const x = tile.clientWidth;\n      const y = tile.clientHeight;\n      return {x, y};\n    }\n    return {x: 0, y: 0};\n  }\n\n  tileID(id:string) {\n    return `${this.el.id}${this.el.id ? '-': ''}tile-${id}`;\n  }\n\n  createTile(id: string, spec:TileSpec):HTMLElement {\n    let tile = this.getTile(id);\n    if (!tile) {\n      tile = document.createElement('div');\n      this.el.appendChild(tile)\n      tile.id = this.tileID(id)\n    }\n    return this.updateTile(tile, spec) as HTMLElement;\n  }\n\n  updateTile(elOrID:HTMLElement|string, spec:TileSpec) {\n    const tile = this.getTile(elOrID);\n    if (!tile) return null;\n    if (spec.text) tile.innerText = spec.text;\n    if (spec.fg) tile.style.color = spec.fg;\n    if (spec.bg) tile.style.backgroundColor = spec.bg;\n    if (spec.tag) {\n      tile.className = 'tile';\n      if (typeof spec.tag === 'string') tile.classList.add(spec.tag);\n      else if (Array.isArray(spec.tag)) for (const tag of spec.tag) tile.classList.add(tag);\n    } else if (!tile.className) tile.className = 'tile';\n    if (spec.pos) this.moveTileTo(tile, spec.pos);\n    if (spec.data) {\n      for (const name in tile.dataset)\n        if (!(name in spec.data))\n          delete tile.dataset[name];\n      for (const name in spec.data)\n        tile.dataset[name] = JSON.stringify(spec.data[name]);\n    }\n    return tile;\n  }\n\n  getTile(elOrID:HTMLElement|string):HTMLElement|null {\n    if (typeof elOrID === 'string') {\n      return this.el.querySelector('#' + this.tileID(elOrID));\n    }\n    return elOrID;\n  }\n\n  getTileData(elOrID:HTMLElement|string, name:string):TileDatum|null {\n    const tile = this.getTile(elOrID);\n    const sval = tile?.dataset[name];\n    if (!sval) return null;\n    try {\n      return JSON.parse(sval);\n    } catch(e) {\n    }\n    return null;\n  }\n\n  setTileData(elOrID:HTMLElement|string, name:string, value:TileDatum|null) {\n    const tile = this.getTile(elOrID);\n    if (!tile) return;\n    if (value === null) delete tile.dataset[name];\n    else                       tile.dataset[name] = JSON.stringify(value);\n  }\n\n  queryTiles(...tag:string[]) {\n    const res : HTMLElement[] = [];\n    for (const el of this.el.querySelectorAll(`.tile${tag.map(t => `.${t}`).join('')}`))\n      res.push(el as HTMLElement);\n    return res;\n  }\n\n  clear() {\n    while (this.el.firstChild) this.el.removeChild(this.el.firstChild);\n  }\n\n  getTilePosition(elOrID:HTMLElement|string) {\n    const tile = this.getTile(elOrID);\n    if (!tile) return {x: NaN, y: NaN};\n    const x = parseFloat(tile.style.getPropertyValue('--x')) || 0;\n    const y = parseFloat(tile.style.getPropertyValue('--y')) || 0;\n    return {x, y};\n  }\n\n  moveTileTo(elOrID:HTMLElement|string, pt:Point):Point {\n    const tile = this.getTile(elOrID);\n    if (!tile) return {x: NaN, y: NaN};\n    tile.style.setProperty('--x', pt.x.toString());\n    tile.style.setProperty('--y', pt.y.toString());\n    // TODO decouple/batch these with a mutation observer?\n    this.spatialIndex.update([tile.id], [pt]);\n    return pt;\n  }\n\n  moveTileBy(elOrID:HTMLElement|string, {x: dx, y: dy}:Point) {\n    const tile = this.getTile(elOrID);\n    if (!tile) return {x: NaN, y: NaN};\n    let {x, y} = this.getTilePosition(tile);\n    x += dx, y += dy;\n    return this.moveTileTo(tile, {x, y});\n  }\n\n  spatialIndex:TileSpatialIndex = new TileMortonIndex()\n\n  tilesAtPoint(clientX:number, clientY:number) {\n    return document\n      .elementsFromPoint(clientX, clientY)\n      .filter(el => el.classList.contains('tile')) as HTMLElement[];\n  }\n\n  tilesAt(at:Point, ...tag:string[]):HTMLElement[] {\n    let tiles : HTMLElement[] = [];\n    const ids = this.spatialIndex.tilesAt(at);\n    if (!ids) return tiles;\n    for (const id of ids) {\n      const el = this.el.querySelector(`#${id}`);\n      if (el) tiles.push(el as HTMLElement);\n    }\n    if (tag.length) tiles = tiles\n      .filter(el => tag.every(t => el.classList.contains(t)));\n    return tiles;\n  }\n\n  get viewOffset() {\n    const x = parseFloat(this.el.style.getPropertyValue('--xlate-x')) || 0;\n    const y = parseFloat(this.el.style.getPropertyValue('--xlate-y')) || 0;\n    return {x, y};\n  }\n\n  get viewport() {\n    const\n      tileSize = this.tileSize,\n      {x, y} = this.viewOffset,\n      width = this.el.clientWidth  / tileSize.x,\n      height = this.el.clientHeight / tileSize.y;\n    return {x, y, width, height};\n  }\n\n  moveViewTo({x, y}:Point) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n    this.el.style.setProperty('--xlate-x', x.toString());\n    this.el.style.setProperty('--xlate-y', y.toString());\n    return {x, y};\n  }\n\n  moveViewBy({x: dx, y: dy}:Point) {\n    const {x, y} = this.viewOffset;\n    return this.moveViewTo({x: x + dx, y: y + dy});\n  }\n\n  centerViewOn({x, y}:Point) {\n    const {width, height} = this.viewport;\n    x -= width / 2, y -= height / 2;\n    return this.moveViewTo({x, y});\n  }\n\n  nudgeViewTo({x, y}:Point, nudge:Point|number) {\n    let {x: vx, y: vy, width, height} = this.viewport;\n    let nx = width, ny = height;\n    if (typeof nudge === 'number') nx *= nudge,   ny *= nudge;\n    else                           nx  = nudge.x, ny  = nudge.y;\n    while (true) {\n      const dx = x < vx ? -1 : x > vx + width ? 1 : 0;\n      const dy = y < vy ? -1 : y > vy + height ? 1 : 0;\n      if      (dx < 0) vx -= nx;\n      else if (dx > 0) vx += nx;\n      else if (dy < 0) vy -= ny;\n      else if (dy > 0) vy += ny;\n      else             return this.moveViewTo({x: vx, y: vy});\n    }\n  }\n}\n\nexport interface TileInspectEvent {\n  pos:Point\n  tiles:HTMLElement[]\n}\n\nexport class TileInspector {\n  grid: TileGrid\n  handler: (ev:TileInspectEvent)=>void\n\n  constructor(\n    grid:TileGrid,\n    handler:(ev:TileInspectEvent)=>void,\n  ) {\n    this.grid = grid;\n    this.handler = handler;\n    this.grid.el.addEventListener('mousemove', this.mouseMoved.bind(this));\n  }\n\n  #inspectingIDs:string = ''\n\n  mouseMoved(ev:MouseEvent) {\n    const tiles = this.grid.tilesAtPoint(ev.clientX, ev.clientY);\n    const ids = tiles.map(({id}) => id).join(';');\n    if (this.#inspectingIDs === ids) return;\n    this.#inspectingIDs = ids;\n    const pos = this.grid.getTilePosition(tiles[0]);\n    this.handler({pos, tiles});\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
