{
  "version": 3,
  "sources": ["/Users/jcorbin/borkshop-js/packages/jspit/src/dla.ts"],
  "sourcesContent": ["import {html, render} from 'lit-html';\nimport {bindVars} from './config';\nimport {Point, TileGrid, TileInspector, TileInspectEvent} from './tiles';\nimport {KeyMap, coalesceMoves} from './input';\nimport {everyFrame, schedule} from './anim';\nimport {show as showUI, Bindings as UIBindings} from './ui';\n\nconst enum InitWhere {\n  Seed = 0,\n  RandSeed,\n  RandPrior,\n  RandVoid,\n  RandAny,\n}\n\nexport class DLA {\n  static demoName = 'DLA'\n  static demoTitle = 'Diffusion Limited Aggregation'\n\n  // rate at which to coalesce and process movement input\n  static inputRate = 100\n\n  // proportion to scroll viewport by when at goes outside\n  static nudgeBy = 0.2\n\n  static settings = {\n    genRate:   1,\n    playRate:  100,\n\n    bounds: {\n      x: -15, y: -15,\n      w:  30, h:  30,\n    },\n\n    seeds: [\n      {x: 0, y: 0},\n    ],\n\n    initWhere: {\n      value: InitWhere.RandAny,\n      options: [\n        {label: 'First Seed', value: InitWhere.Seed},\n        {label: 'Random Seed', value: InitWhere.RandSeed},\n        {label: 'Random Point: World', value: InitWhere.RandPrior},\n        {label: 'Random Point: Void', value: InitWhere.RandVoid},\n        {label: 'Random Point', value: InitWhere.RandAny},\n      ],\n    },\n    initAnyBalance: 0.25,\n    initBase: 0,\n    initArc:  2.0,\n\n    turnLeft:  0.1,\n    turnRight: 0.1,\n\n    stepLimit: 0,\n    particleLimit: 0,\n\n    ordinalMoves: false,\n  }\n\n  particleID = 0\n\n  grid: TileGrid\n\n  constructor(grid:TileGrid) {\n    const {seeds} = DLA.settings;\n\n    this.grid = grid;\n    this.grid.clear();\n    const center = {x: NaN, y: NaN};\n    for (const pos of seeds) {\n      this.grid.createTile(`particle-${++this.particleID}`, {\n        tag: ['particle', 'init'],\n        pos,\n        text: '\u00B7',\n      });\n      if (isNaN(center.x) || isNaN(center.y)) center.x = pos.x, center.y = pos.y;\n      else center.x = (center.x + pos.x)/2, center.y = (center.y + pos.y)/2;\n    }\n    if (!isNaN(center.x) && !isNaN(center.y)) this.grid.centerViewOn(center);\n  }\n\n  elapsed = 0\n\n  dropPlayer() {\n    const {seeds} = DLA.settings;\n    const pos = seeds[0];\n    this.grid.createTile('at', {\n      tag: ['solid', 'mind', 'keyMove'],\n      pos,\n      fg: 'var(--dla-player)',\n      text: '@',\n    });\n  }\n\n  initPlace():Point {\n    const {bounds, seeds, initWhere: {value: where}, initAnyBalance} = DLA.settings;\n\n    const chooseVoid = () => {\n      while (true) {\n        const pos = {\n          x: bounds.x + Math.random() * bounds.w,\n          y: bounds.y + Math.random() * bounds.h,\n        };\n        const at = this.grid.tilesAt(pos, 'particle')\n          .filter(t => !t.classList.contains('live'));\n        if (!at.length) return pos;\n      }\n    };\n\n    const choosePrior = () => {\n      const prior = this.grid.queryTiles({tag: 'particle'})\n        .filter(t => !t.classList.contains('live'));\n      const tile = prior[Math.floor(Math.random()*prior.length)];\n      return this.grid.getTilePosition(tile);\n    };\n\n    switch (where) {\n\n    case InitWhere.Seed:\n      return seeds[0]; // TODO round robin all seeds?\n    case InitWhere.RandSeed:\n      return seeds[Math.floor(Math.random()*seeds.length)];\n\n    case InitWhere.RandPrior: return choosePrior();\n    case InitWhere.RandVoid:  return chooseVoid();\n    case InitWhere.RandAny:\n        const nVoid  = this.grid.queryTiles({tag: ['particle', 'void']}).length;\n        const nPrime = this.grid.queryTiles({tag: ['particle', 'prime']}).length;\n        const total  = nVoid + nPrime;\n        const sVoid  = Math.pow(Math.random(), nVoid  - total * (1 - initAnyBalance));\n        const sPrime = Math.pow(Math.random(), nPrime - total *      initAnyBalance);\n        return sPrime >= sVoid ? choosePrior() : chooseVoid();\n\n    default:\n      throw new Error(`invalid initWhere value ${where}`);\n    }\n  }\n\n  spawn():HTMLElement|null {\n    const ghost = this.grid.queryTile({\n      tag: 'ghost',\n      id: '^particle-',\n    });\n    if (!ghost && this.particleID >= this.particleLimit()) return null;\n\n    const {initBase, initArc} = DLA.settings;\n    const pos = this.initPlace();\n    const heading = Math.PI * (initBase + (Math.random() - 0.5) * initArc);\n    const kind = this.anyCell(pos) ? 'prime' : 'void';\n    const spec = {\n      tag: ['particle', 'live', kind],\n      pos,\n      text: '*',\n      data: {heading},\n    };\n    if (ghost)\n      return this.grid.updateTile(ghost, spec);\n    return this.grid.createTile(`particle-${++this.particleID}`, spec);\n  }\n\n  stepLimit():number {\n    const {bounds, stepLimit} = DLA.settings;\n    if (stepLimit > 0) return stepLimit;\n    return bounds.w + bounds.h;\n  }\n\n  particleLimit():number {\n    const {bounds, particleLimit} = DLA.settings;\n    if (particleLimit > 0) {\n      if (particleLimit > 1) return particleLimit;\n      return (bounds.w * bounds.h)*particleLimit;\n    }\n    return (bounds.w * bounds.h)/2;\n  }\n\n  anyCell(...pts:Point[]):boolean {\n    for (const pt of pts)\n      if (this.grid.tilesAt(pt, 'particle')\n          .filter(t => !t.classList.contains('live'))\n          .length) return true;\n    return false;\n  }\n\n  update(dt:number): void {\n    const {\n      genRate, playRate,\n      turnLeft, turnRight,\n      ordinalMoves,\n    } = DLA.settings;\n\n    const havePlayer = !!this.grid.queryTile({tag: 'keyMove'});\n\n    const rate = havePlayer ? playRate : genRate;\n    this.elapsed += dt\n    const n = Math.floor(this.elapsed / rate);\n    if (!n) return;\n    this.elapsed -= n * rate;\n    let ps = this.grid.queryTiles({tag: ['particle', 'live']});\n\n    for (let i = 0; i < n; ++i) {\n      ps = ps.filter(p => p.classList.contains('live'));\n      if (!ps.length) {\n        const p = this.spawn();\n        if (!p) {\n          if (!havePlayer) this.dropPlayer();\n          return;\n        }\n        ps.push(p);\n        continue;\n      }\n\n      for (const p of ps) {\n        let steps = this.grid.getTileData(p, 'steps');\n        if (typeof steps !== 'number') steps = 0;\n        this.grid.setTileData(p, 'steps', ++steps);\n\n        let heading = this.grid.getTileData(p, 'heading');\n        if (typeof heading !== 'number') heading = 0;\n\n        const adj = Math.random() * (turnLeft + turnRight) - turnLeft;\n        heading += Math.PI * adj;\n        heading %= 2 * Math.PI;\n        this.grid.setTileData(p, 'heading', heading);\n\n        const p1 = this.grid.getTilePosition(p);\n\n        // move along heaading... somehow\n        const p2 = {x: p1.x, y: p1.y};\n        let dx = Math.cos(heading);\n        let dy = Math.sin(heading);\n        if (!ordinalMoves) {\n          // movement clamped to cardinal directions, with optional tracking of\n          // \"debt\" from the diagonal not taken\n          const prior = this.grid.getTileData(p, 'prior');\n          if (prior !== null && typeof prior === 'object' && !Array.isArray(prior)) {\n            if (typeof prior.x === 'number') dx += prior.x;\n            if (typeof prior.y === 'number') dy += prior.y;\n          }\n          if (Math.abs(dy) > Math.abs(dx)) {\n            if (dy < 0) p2.y++, dy++;\n            else        p2.y--, dy--;\n          } else {\n            if (dx < 0) p2.x++, dx++;\n            else        p2.x--, dx--;\n          }\n          this.grid.setTileData(p, 'prior', {x: dx, y: dy});\n        } else {\n          // smooth movement, taking fractional positions\n          p2.x += dx;\n          p2.y += dy;\n        }\n\n        // clamped to grid boundaries\n        const p3 = {x: Math.floor(p1.x), y: Math.floor(p1.y)};\n        const p4 = {x: Math.floor(p2.x), y: Math.floor(p2.y)};\n\n        // check for phase transition when entering a new grid cell based on\n        // what non-live particle prescence\n        if (p3.x !== p4.x || p3.y !== p4.y) {\n          const at3 = this.grid.tilesAt(p3, 'particle')\n            .filter(t => t.id !== p.id && !t.classList.contains('live'));\n          const at4 = this.grid.tilesAt(p4, 'particle')\n            .filter(t => !t.classList.contains('live'));\n\n          // in-world particles may forge into the void; aka random walker\n          if (at3.length && !at4.length) {\n            // TODO allow for more than 1 step\n            this.grid.updateTile(p, {\n              tag: ['particle', 'prime'],\n              pos: p4,\n              text: '\u00B7',\n            });\n            continue;\n          }\n\n          // in-void particle aggregating onto world; aka DLA depostion\n          else if (!at3.length && (\n            at4.length\n            || this.anyCell(\n              {x: p3.x,   y: p3.y-1},\n              {x: p3.x+1, y: p3.y},\n              {x: p3.x,   y: p3.y+1},\n              {x: p3.x-1, y: p3.y},\n            )\n            || (ordinalMoves && this.anyCell(\n              {x: p3.x+1, y: p3.y-1},\n              {x: p3.x+1, y: p3.y+1},\n              {x: p3.x-1, y: p3.y+1},\n              {x: p3.x-1, y: p3.y-1},\n            ))\n          )) {\n            this.grid.updateTile(p, {\n              tag: ['particle', 'void'],\n              pos: p3,\n              text: '\u00B7',\n            });\n            continue;\n          }\n        }\n\n        this.grid.moveTileTo(p, p2);\n\n        // increment step counter, and leave a ghost if limit met or exceeded\n        if (steps >= this.stepLimit()) {\n          this.grid.updateTile(p, {\n            tag: ['ghost'],\n            pos: p1,\n          });\n        }\n      }\n    }\n  }\n\n  digSeq = new Map<string, number>()\n\n  consumeInput(presses: Array<[string, number]>):void {\n    const movers = this.grid.queryTiles({tag: 'keyMove'});\n    if (!movers.length) return;\n    if (movers.length > 1) throw new Error(`ambiguous ${movers.length}-mover situation`);\n    const actor = movers[0];\n\n    let {have, move} = coalesceMoves(presses);\n    if (!have) return;\n\n    const pos = this.grid.getTilePosition(actor);\n    const targ = {x: pos.x + move.x, y: pos.y + move.y};\n\n    // solid actors subject to collison\n    if (actor.classList.contains('solid')) {\n      const hits = this.grid.tilesAt(targ);\n\n      if (!hits.length) {\n        // // TODO bring back this power\n        // // place particles in the void\n        // const aid = actor.id;\n        // const did = (this.digSeq.get(aid) || 0) + 1;\n        // this.digSeq.set(aid, did);\n        // this.grid.createTile(`particle-placed-${aid}-${did}`, {\n        //   tag: ['particle'],\n        //   pos: targ,\n        //   fg: 'var(--dla-player)',\n        //   text: '\u00B7',\n        // });\n        return;\n      } else {\n        // can only move there if have particle support\n        if (!hits.some((h) => h.classList.contains('particle'))) return;\n      }\n    }\n\n    this.grid.moveTileTo(actor, targ);\n    this.grid.nudgeViewTo(targ, DLA.nudgeBy);\n  }\n\n  running = false\n\n  run(\n    readKeys:() => Array<[string, number]>,\n    update?:(dt:number) => void,\n  ) {\n\n    this.running = true;\n    everyFrame(schedule(\n      () => this.running,\n\n      {every: DLA.inputRate, then: () => {\n        this.consumeInput(readKeys());\n        return true;\n      }},\n\n      // TODO hoist dynamic tick rate into into anim.schedule\n      // {every: () => this.rate, then: (dn) => {\n      // }),\n\n      (dt:number) => {\n        this.update(dt);\n        if (update) update(dt);\n        return true;\n      },\n    ));\n  }\n}\n\n// injected DOM parts\ninterface Bindings extends UIBindings {\n  menu: HTMLElement,\n  grid: HTMLElement,\n  status: HTMLElement,\n  keys: HTMLElement,\n  run: HTMLButtonElement,\n  reset: HTMLButtonElement,\n  dropPlayer: HTMLButtonElement,\n  inspector: HTMLTextAreaElement,\n  inspectorAt: HTMLElement,\n}\nexport const bound:Partial<Bindings> = {};\n\n// simulation / \"game\" state and dependencies\ninterface State {\n  grid: TileGrid,\n  inspector: TileInspector,\n  keys: KeyMap,\n  world: DLA,\n}\nexport const state:Partial<State> = {};\n\nfunction onInsepcted({pos: {x, y}, tiles}:TileInspectEvent) {\n  if (bound.inspectorAt) {\n    bound.inspectorAt.innerText = `${isNaN(x) ? 'X' : Math.floor(x)},${isNaN(y) ? 'Y' : Math.floor(y)}`;\n  }\n  if (bound.inspector) {\n    // TODO a <select> might be neat, but would need more than an ephemeral\n    // \"hold space\" interaction mode\n    const lines = tiles.map(t => {\n      let line = `id=${t.id}`\n      line += ` tag=[${Array.from(t.classList).filter(n => n !== 'tile').join(', ')}]`;\n      return line;\n    });\n    bound.inspector.value = lines.join('\\n');\n    bound.inspector.rows = lines.length;\n    bound.inspector.cols = lines.reduce((max, line) => Math.max(max, line.length), 0);\n  }\n}\n\nexport function init(bind:Bindings) {\n  Object.assign(bound, bind);\n\n  if (bound.grid) {\n    state.grid = new TileGrid(bound.grid);\n    if (bound.inspector) {\n      state.inspector = new TileInspector(state.grid, onInsepcted);\n      state.inspector.disable();\n    }\n  }\n\n  if (bound.keys) state.keys = new KeyMap(bound.keys, (ev:KeyboardEvent):boolean => {\n\n    if (ev.key === 'Escape') {\n      if (ev.type === 'keydown') playPause();\n      return false;\n    }\n\n    if (ev.code === 'Space') {\n      const enabled = ev.type === 'keydown';\n      if (enabled) state.inspector?.enable();\n      else         state.inspector?.disable();\n      state.grid?.el.classList.toggle('inspectable', enabled && !!state.inspector);\n      state.grid?.el.classList.toggle('retro', enabled);\n      return false;\n    }\n\n    if (!state.world?.running) return false;\n    return !ev.altKey && !ev.ctrlKey && !ev.metaKey;\n  });\n\n  bound.run?.addEventListener('click', playPause);\n  bound.reset?.addEventListener('click', () => {\n    if (state.world) state.world.running = false;\n    state.world = undefined;\n    if (bound.reset) bound.reset.disabled = true;\n    showUI(bound, false, false);\n  });\n  bound.dropPlayer?.addEventListener('click', () => {\n    if (state.world) {\n      if (bound.dropPlayer) bound.dropPlayer.disabled = true;\n      state.world.dropPlayer();\n    }\n  });\n\n  bindVars({\n    data: DLA.settings,\n    getInput: (name:string) => bound.menu?.querySelector(`input[name=\"${name}\"]`) || null,\n    getSelect: (name:string) => bound.menu?.querySelector(`select[name=\"${name}\"]`) || null,\n  });\n\n  showUI(bound, false, false);\n}\n\nfunction playPause() {\n  if (!state.grid) return;\n\n  showUI(bound, true, !state.world?.running);\n\n  if (!state.world) {\n    state.world = new DLA(state.grid);\n    if (bound.dropPlayer) bound.dropPlayer.disabled = false;\n    if (bound.reset) bound.reset.disabled = false;\n  }\n\n  const {world, keys} = state;\n  if (world.running) world.running = false;\n  else world.run(\n    () => keys?.consumePresses() || [],\n    () => bound.status && render(html`\n        <label for=\"particleID\">Particles:</label>\n        <span id=\"particleID\">${world.particleID}</span>\n      `, bound.status));\n}\n"],
  "mappings": "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",
  "names": []
}
