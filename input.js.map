{
  "version": 3,
  "sources": ["/Users/jcorbin/borkshop-js/packages/jspit/src/input.ts"],
  "sourcesContent": ["export class KeyMap extends Map<string, number> {\n  filter?: (keyEvent:KeyboardEvent) => boolean\n  target: EventTarget\n  #handler: (ev:Event)=>void\n\n  constructor(\n    target: EventTarget,\n    filter?: (keyEvent:KeyboardEvent) => boolean,\n  ) {\n    super();\n    this.#handler = this.handleEvent.bind(this);\n    this.filter = filter;\n    this.target = target;\n    this.target.addEventListener('keydown', this.#handler);\n    this.target.addEventListener('keyup', this.#handler);\n  }\n\n  countKey({altKey, ctrlKey, metaKey, shiftKey, key}:KeyboardEvent) {\n    const name = `${\n      altKey ? 'A-' : ''}${\n      ctrlKey ? 'C-' : ''}${\n      metaKey ? 'M-' : ''}${\n      shiftKey ? 'S-' : ''}${\n      key}`;\n    const n = this.get(name) || 0;\n    this.set(name, n+1);\n  }\n\n  handleEvent(event:Event) {\n    if (event.type !== 'keyup' && event.type !== 'keydown') return;\n    const keyEvent = event as KeyboardEvent;\n    if (this.filter && !this.filter(keyEvent)) return;\n    this.countKey(keyEvent);\n    event.stopPropagation();\n    event.preventDefault();\n  }\n\n  consumePresses() {\n    const presses :Array<[string, number]> = [];\n    for (const [name, count] of Array.from(this.entries())) {\n      const n = Math.floor(count / 2);\n      if (n > 0) {\n        const d = count % 2;\n        if (d == 0) this.delete(name);\n        else        this.set(name, 1);\n        presses.push([name, n]);\n      }\n    }\n    return presses;\n  }\n}\n\nfunction parseMoveKey(key:string) {\n  switch (key) {\n    // arrow keys + stay\n    case 'ArrowUp':    return {x:  0, y: -1};\n    case 'ArrowRight': return {x:  1, y:  0};\n    case 'ArrowDown':  return {x:  0, y:  1};\n    case 'ArrowLeft':  return {x: -1, y:  0};\n    case '.':          return {x:  0, y:  0};\n    default:           return null;\n  }\n}\n\nexport function coalesceMoves(presses:Array<[string, number]>) {\n  return presses\n    .map(([key, _count]) => parseMoveKey(key))\n    .reduce((acc, move) => {\n      if (move) {\n        acc.move.x += move.x;\n        acc.move.y += move.y;\n        acc.have = true\n      }\n      return acc;\n    }, {\n      have: false,\n      move: {x: 0, y: 0},\n    });\n}\n"],
  "mappings": "AAAA,4BAA4B;AAAA;AAAA,EAK1B,YACE,QACA;AAEA;AACA,oBAAgB,KAAK,YAAY,KAAK;AACtC,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,OAAO,iBAAiB,WAAW;AACxC,SAAK,OAAO,iBAAiB,SAAS;AAAA;AAAA,EAGxC,SAAS,CAAC,QAAQ,SAAS,SAAS,UAAU;AAC5C,UAAM,OAAO,GACX,SAAS,OAAO,KAChB,UAAU,OAAO,KACjB,UAAU,OAAO,KACjB,WAAW,OAAO,KAClB;AACF,UAAM,IAAI,KAAK,IAAI,SAAS;AAC5B,SAAK,IAAI,MAAM,IAAE;AAAA;AAAA,EAGnB,YAAY;AACV,QAAI,MAAM,SAAS,WAAW,MAAM,SAAS;AAAW;AACxD,UAAM,WAAW;AACjB,QAAI,KAAK,UAAU,CAAC,KAAK,OAAO;AAAW;AAC3C,SAAK,SAAS;AACd,UAAM;AACN,UAAM;AAAA;AAAA,EAGR;AACE,UAAM,UAAmC;AACzC,eAAW,CAAC,MAAM,UAAU,MAAM,KAAK,KAAK;AAC1C,YAAM,IAAI,KAAK,MAAM,QAAQ;AAC7B,UAAI,IAAI;AACN,cAAM,IAAI,QAAQ;AAClB,YAAI,KAAK;AAAG,eAAK,OAAO;AAAA;AACZ,eAAK,IAAI,MAAM;AAC3B,gBAAQ,KAAK,CAAC,MAAM;AAAA;AAAA;AAGxB,WAAO;AAAA;AAAA;AAIX,sBAAsB;AACpB,UAAQ;AAAA,SAED;AAAc,aAAO,CAAC,GAAI,GAAG,GAAG;AAAA,SAChC;AAAc,aAAO,CAAC,GAAI,GAAG,GAAI;AAAA,SACjC;AAAc,aAAO,CAAC,GAAI,GAAG,GAAI;AAAA,SACjC;AAAc,aAAO,CAAC,GAAG,IAAI,GAAI;AAAA,SACjC;AAAc,aAAO,CAAC,GAAI,GAAG,GAAI;AAAA;AACnB,aAAO;AAAA;AAAA;AAIvB,8BAAuB;AAC5B,SAAO,QACJ,IAAI,CAAC,CAAC,KAAK,YAAY,aAAa,MACpC,OAAO,CAAC,KAAK;AACZ,QAAI;AACF,UAAI,KAAK,KAAK,KAAK;AACnB,UAAI,KAAK,KAAK,KAAK;AACnB,UAAI,OAAO;AAAA;AAEb,WAAO;AAAA,KACN;AAAA,IACD,MAAM;AAAA,IACN,MAAM,CAAC,GAAG,GAAG,GAAG;AAAA;AAAA;",
  "names": []
}
